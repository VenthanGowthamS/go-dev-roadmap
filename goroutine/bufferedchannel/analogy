    +-----------------------------+
    |       Buffered Channel       |
    |                             |
    |  +-------+-------+-------+  |
    |  |   A   |   B   |   C   |  |  <-- Buffer slots filled
    |  +-------+-------+-------+  |
    |                             |
    +-----------------------------+
          ^       ^       ^
         /         \       \
Goroutine1   Goroutine2  Goroutine3   (senders filled the buffer)

Next senders block here waiting:
Goroutine4 (D)  [BLOCKED]
Goroutine5 (E)  [BLOCKED]
Goroutine6 (F)  [BLOCKED]

Receiver starts reading:
<-ch reads A â†’ frees slot â†’ unblocks Goroutine4 â†’ D stored

Buffer after receiving A and sending D:
    +-------+-------+-------+
    |   B   |   C   |   D   |
    +-------+-------+-------+



ðŸ“¦ Analogy for Buffered Channel (Think of a Box with Slots)
ðŸ”§ Setup:
Channel with buffer size 3 â†’ box with 3 empty slots.

6 goroutines try to send a message into this box.

Receiver takes messages out of the box.

  [Buffered Channel] â†’ Think of a message box with 3 slots

      +-------+-------+-------+
Slot: |   A   |   B   |   C   |  â† buffer filled by first 3 goroutines
      +-------+-------+-------+
             â†‘
        Ch is full now
Now, other goroutines (trying to send D, E, F) get stuck:
   Goroutines trying to send:
   D â†’ BLOCKED (waiting)
   E â†’ BLOCKED (waiting)
   F â†’ BLOCKED (waiting)
Then, the receiver starts pulling:
Main: <-ch â†’ pulls A  â†’ box = [B, C]
       â†’ unblocks goroutine D
       â†’ D pushes to box â†’ box = [B, C, D]
This continues until all 6 messages are sent and received.

1. First 3 goroutines fill the channel buffer.
2. Remaining goroutines block on send (â† ch).
3. Main goroutine starts receiving (â†’ ch).
4. As buffer frees up, blocked goroutines send.
5. Repeat until all done.


Unbuffered Channel = No box, just a handshake

    Goroutine: ch <- "msg"    â†’ waits at the door
    Main:      <- ch          â†’ opens door
    Message passed directly
